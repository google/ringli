// Copyright 2024 The Ringli Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef COMMON_DCT_H_
#define COMMON_DCT_H_

#include <math.h>

#include <cmath>

#include "common/data_defs/data_matrix.h"
#include "common/data_defs/data_vector.h"

namespace ringli {

// Implementation of Lowest Complexity Self Recursive Radix-2 DCT II/III
// Algorithms, by Siriani M. Perera and Jianhua Liu.

// Constants for DCT implementation. Generated by the following snippet:
// for i in range(N // 2):
//    print(1.0 / (2 * math.cos((i + 0.5) * math.pi / N)), end=", ")
template <size_t N>
struct WcMultipliers;

template <>
struct WcMultipliers<4> {
  static constexpr float kMultipliers[] = {
      0.541196100146197,
      1.3065629648763764,
  };
};

template <>
struct WcMultipliers<8> {
  static constexpr float kMultipliers[] = {
      0.5097955791041592,
      0.6013448869350453,
      0.8999762231364156,
      2.5629154477415055,
  };
};

template <>
struct WcMultipliers<16> {
  static constexpr float kMultipliers[] = {
      0.5024192861881557, 0.5224986149396889, 0.5669440348163577,
      0.6468217833599901, 0.7881546234512502, 1.060677685990347,
      1.7224470982383342, 5.101148618689155,
  };
};

template <>
struct WcMultipliers<32> {
  static constexpr float kMultipliers[] = {
      0.5006029982351963, 0.5054709598975436, 0.5154473099226246,
      0.5310425910897841, 0.5531038960344445, 0.5829349682061339,
      0.6225041230356648, 0.6748083414550057, 0.7445362710022986,
      0.8393496454155268, 0.9725682378619608, 1.1694399334328847,
      1.4841646163141662, 2.057781009953411,  3.407608418468719,
      10.190008123548033,
  };
};
template <>
struct WcMultipliers<64> {
  static constexpr float kMultipliers[] = {
      0.500150636020651,  0.5013584524464084, 0.5037887256810443,
      0.5074711720725553, 0.5124514794082247, 0.5187927131053328,
      0.52657731515427,   0.535909816907992,  0.5469204379855088,
      0.5597698129470802, 0.57465518403266,   0.5918185358574165,
      0.6115573478825099, 0.6342389366884031, 0.6603198078137061,
      0.6903721282002123, 0.7251205223771985, 0.7654941649730891,
      0.8127020908144905, 0.8683447152233481, 0.9345835970364075,
      1.0144082649970547, 1.1120716205797176, 1.233832737976571,
      1.3892939586328277, 1.5939722833856311, 1.8746759800084078,
      2.282050068005162,  2.924628428158216,  4.084611078129248,
      6.796750711673633,  20.373878167231453,
  };
};

template <int SIZE>
DataVector<float, SIZE> InvScale(const DataVector<float, SIZE>& input) {
  const float inv_scale = 1.0f / std::sqrt(SIZE);
  DataVector<float, SIZE> output;
  for (int i = 0; i < SIZE; ++i) output[i] = inv_scale * input[i];
  return output;
}

static inline DataVector<float, 2> ScaledForwardDCT(
    const DataVector<float, 2>& input) {
  DataVector<float, 2> output;
  output[0] = input[0] + input[1];
  output[1] = input[0] - input[1];
  return output;
}

template <int N>
DataVector<float, N> ScaledForwardDCT(const DataVector<float, N>& input) {
  constexpr int N1 = N / 2;
  DataVector<float, N1> u1, u2;
  for (int i = 0; i < N1; ++i) {
    u1[i] = input[i] + input[N - 1 - i];
    u2[i] = input[i] - input[N - 1 - i];
    u2[i] *= WcMultipliers<N>::kMultipliers[i];
  }
  DataVector<float, N1> z1 = ScaledForwardDCT(u1);
  DataVector<float, N1> z2 = ScaledForwardDCT(u2);
  z2[0] *= std::sqrt(2.0f);
  for (int i = 0; i + 1 < N1; ++i) {
    z2[i] += z2[i + 1];
  }
  DataVector<float, N> output;
  for (int i = 0; i < N1; ++i) {
    output[2 * i + 0] = z1[i];
    output[2 * i + 1] = z2[i];
  }
  return output;
}

static inline DataVector<float, 2> ScaledInverseDCT(
    const DataVector<float, 2>& input) {
  DataVector<float, 2> output;
  output[0] = input[0] + input[1];
  output[1] = input[0] - input[1];
  return output;
}

template <int N>
DataVector<float, N> ScaledInverseDCT(const DataVector<float, N>& input) {
  constexpr int N1 = N / 2;
  DataVector<float, N1> u1, u2;
  for (int i = 0; i < N1; ++i) {
    u1[i] = input[2 * i + 0];
    u2[i] = input[2 * i + 1];
  }
  for (int i = N1 - 1; i >= 1; --i) {
    u2[i] += u2[i - 1];
  }
  u2[0] *= std::sqrt(2.0f);
  DataVector<float, N1> z1 = ScaledInverseDCT(u1);
  DataVector<float, N1> z2 = ScaledInverseDCT(u2);
  for (int i = 0; i < N1; ++i) {
    z2[i] *= WcMultipliers<N>::kMultipliers[i];
  }
  DataVector<float, N> output;
  for (int i = 0; i < N1; ++i) {
    output[i] = z1[i] + z2[i];
    output[i + N1] = z1[N1 - 1 - i] - z2[N1 - 1 - i];
  }
  return output;
}

template <int SIZE>
DataVector<float, SIZE> ForwardDCT(const DataVector<float, SIZE>& input) {
  return InvScale(ScaledForwardDCT(input));
}

template <int SIZE>
DataVector<float, SIZE> InverseDCT(const DataVector<float, SIZE>& input) {
  return InvScale(ScaledInverseDCT(input));
}

}  // namespace ringli

#endif  // COMMON_DCT_H_
